[{"title":"Explain IPv4 and IPv6 header checksum algorithm","url":"/en/2021-12-26-Analyze-IPv4-IPv6-checksum.html","content":"<p>About IP packet header checksum algorithm, simply put, it is 16-bit ones' complement of the ones' complement sum of all 16-bit words in the header. However, not many sources show exactly how this is done.<span id=\"more\"></span> The same checksum algorithm is used by TCP segment and UDP datagram, but the data involved in the checksum is different from that in the IP header. In addition, the checksum operation of IPv6 is slightly different from that of IPv4. Therefore, it is necessary to make a comprehensive analysis of the checksum algorithm of IP packets.</p>\n<div class=\"note success no-icon\"><p><strong>Nothing in life is to be feared, it is only to be understood.</strong><br> <strong>— <em>Marie Curie</em> (Polish and naturalized-French physicist and chemist, twice Nobel Prize winner)</strong></p>\n</div>\n<h2 id=\"ipv4-header-checksum\">IPv4 Header Checksum</h2>\n<p>IPv4 packet header format can be seen below</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">0                   1                   2                   3    </span><br><span class=\"line\">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  </span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|         Identification        |Flags|      Fragment Offset    |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|  Time to Live |    Protocol   |        Header Checksum        |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                       Source Address                          |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                    Destination Address                        |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                    Options                    |    Padding    |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>\n<p>Here the 16-bit Header Checksum field is used for error-checking of the. While computing the IPv4 header checksum, the sender first clears the checksum field to zero, then calculates the sum of each 16-bit value within the header. The sum is saved in a 32-bit value. If the total number of bytes is odd, the last byte is added separately.</p>\n<p>After all additions, the higher 16 bits saving the carry is added to the lower 16 bits. Repeat this till all higher 16 bits are zeros. Finally the sender takes the ones' complement of the lower 16 bits of the result and writes it to IP header checuksum field.</p>\n<p>The following demonstrates the entire calculation process using actual captured IPv4 packets.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">0x0000: 00 60 47 41 11 c9 00 09 6b 7a 5b 3b 08 00 45 00 </span><br><span class=\"line\">0x0010: 00 1c 74 68 00 00 80 11 59 8f c0 a8 64 01 ab 46 </span><br><span class=\"line\">0x0020: 9c e9 0f 3a 04 05 00 08 7f c5 00 00 00 00 00 00 </span><br><span class=\"line\">0x0030: 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>\n<p>At the beginning of the above 16-bit hex dump is the Ethernet frame header. The IP packet header start from offset 0x000e, with the first byte 0x45 and the last byte 0xe9. Based on the previous description of the algorithm, we can make the following calculations:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(1) 0x4500 + 0x001c + 0x7468 + 0x0000 + 0x8011 +</span><br><span class=\"line\">    0x0000 + 0xc0a8 + 0x6401 + 0xab46 + 0x9ce9 = 0x3a66d</span><br><span class=\"line\">(2) 0xa66d + 0x3 = 0xa670</span><br><span class=\"line\">(3) 0xffff - 0xa670 = 0x598f</span><br></pre></td></tr></table></figure>\n<p>Notice at step (1) we replace the checksum field with <u>0x0000</u>. As can be seen, the calculated header checksum 0x598f is exactly the same as the value in the captured packet. This calculating process is only used for the sender to generate the initial checksum. In practice, for the intermediate forwarding router and the final receiver, they can just sum up all header fields of the receive IP packet by the same algorithm. If the result is <u>0xffff</u>, the checksum verification passes.</p>\n<h2 id=\"c-program-implementation\">C Program Implementation</h2>\n<p>How to program IPv4 header checksum computing? <a href=\"https://tools.ietf.org/html/rfc1071\">RFC 1071</a> (Computing the Internet Checksum) shows a reference \"C\" language implementation:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Compute Internet Checksum for &quot;count&quot; bytes</span></span><br><span class=\"line\"><span class=\"comment\">     * beginning at location &quot;addr&quot;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">register</span> <span class=\"keyword\">long</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>( count &gt; <span class=\"number\">1</span> )  &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* This is the inner loop */</span></span><br><span class=\"line\">        sum += * (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> *) addr++;</span><br><span class=\"line\">        count -= <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*  Add left-over byte, if any */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( count &gt; <span class=\"number\">0</span> )</span><br><span class=\"line\">        sum += * (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *) addr;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*  Fold 32-bit sum to 16 bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (sum&gt;&gt;<span class=\"number\">16</span>)</span><br><span class=\"line\">        sum = (sum &amp; <span class=\"number\">0xffff</span>) + (sum &gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    checksum = ~sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>In a real network connection, the source device can call the above code to generate the initial IPv4 header checksum. This checksum is then updated at each step of the routing hop because the router must decrement the Time To Live (TTL) field. <a href=\"https://tools.ietf.org/html/rfc1141\">RFC 1141</a> (Incremental Updating of the Internet Checksum) gives a reference implemenatation of fast checksum update：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sum;</span><br><span class=\"line\">ipptr-&gt;ttl--;                  <span class=\"comment\">/* decrement ttl */</span></span><br><span class=\"line\">sum = ipptr-&gt;Checksum + <span class=\"number\">0x100</span>; <span class=\"comment\">/* increment checksum high byte*/</span></span><br><span class=\"line\">ipptr-&gt;Checksum = (sum + (sum&gt;&gt;<span class=\"number\">16</span>)); <span class=\"comment\">/* add carry */</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"tcpudp-header-checksum\">TCP/UDP Header Checksum</h2>\n<p>For TCP segment and UDP datagram, they both have 16-bit header checkum fields used for error-checking by the destination host. The checksum computing algorithm is the same as IP header, except the difference of covered data. Here the checksum in calculated over the whole TCP/UDP header and the payload, plus a pseudo-header that mimics the IPv4 header as shown below:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> 0      7 8     15 16    23 24    31 </span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|          source address           |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|        destination address        |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|  zero  |protocol| TCP/UDP length  |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure>\n<p>It consists of the source and destination IP addresses, the protocol number (TCP:6/UDP:17), and the total length of the TCP/UDP header and payload (in bytes). The purpose of including the pseudo-header in the checksum computing is to confirm the packet reachs the expected destination and avoid IP spoofing attack. Besides, for IPv4 UDP header checksum is optional, it carries all-zeros if unused.</p>\n<h2 id=\"ipv6-difference\">IPv6 Difference</h2>\n<p>IPv6 is IP protocol version 6, and its main design goal was to resolve the problem of IPv4 address exhaustion. Of course it provides many benefits in other aspects. Although the IPv6 usage is growing slowly, the trend is unstoppable. The latest IPv6 standard is published in <a href=\"https://tools.ietf.org/html/rfc8200\">RFC 8200</a>(Internet Protocol, Version 6 (IPv6) Specification).</p>\n<p>IPv6 packet header format can be seen below</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|Version| Traffic Class |           Flow Label                  |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|         Payload Length        |  Next Header  |   Hop Limit   |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+                                                               +</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+                         Source Address                        +</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+                                                               +</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+                                                               +</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+                      Destination Address                      +</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+                                                               +</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>\n<p>Notice that the IPv6 header does not include a checksum field, a significant difference from IPv4. The absence of a checksum in the IPv6 header furthers the end-to-end principle of Internet design, to simplify router processing and speed up the packet transmission. Protection for the data integrity can be accomplished by error detection at the link layer or the higher-layer protocols between endpoints (such as TCP/UDP on the transport layer). This is why IPv6 forces the UDP layer to set the header checksum.</p>\n<p>For IPv6 TCP segment and UDP datagram header checksum computing, the pseudo-header that mimics the IPv6 header is shown below</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+                                                               +</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+                         Source Address                        +</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+                                                               +</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+                                                               +</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+                      Destination Address                      +</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+                                                               +</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                   Upper-Layer Packet Length                   |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                      zero                     |  Next Header  |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>\n<h2 id=\"udp-lite-application\">UDP-Lite Application</h2>\n<p>In actual IPv6 network applications, UDP-Lite (Lightweight UDP) can be used to balance error detection and transmission efficiency. UDP-Lite has its own protocol number 136, and its standard is described in <a href=\"https://tools.ietf.org/html/rfc8200\">RFC 3828</a> (The Lightweight User Datagram Protocol (UDP-Lite)).</p>\n<p>Referring to the following header format, UDP-Lite uses the same set of <a href=\"https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml\">port number values assigned by the IANA</a> for use by UDP. But it redefines \"length\" field in UDP header to \"Checksum Coverage\", which allows the application layer to control the length of checksummed data. This is usful for the application that can be tolerant of the potentially lossy transmission of the uncovered portion of the data.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> 0              15 16             31</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|     Source      |   Destination   |</span><br><span class=\"line\">|      Port       |      Port       |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|    Checksum     |                 |</span><br><span class=\"line\">|    Coverage     |    Checksum     |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|                                   |</span><br><span class=\"line\">:              Payload              :</span><br><span class=\"line\">|                                   |</span><br><span class=\"line\">+-----------------------------------+</span><br></pre></td></tr></table></figure>\n<p>UDP-Lite protocol defines the values of \"Checksum Coverage\" (in bytes) as shown in the following table:</p>\n<table>\n<colgroup>\n<col style=\"width: 31%\" />\n<col style=\"width: 36%\" />\n<col style=\"width: 31%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: center;\">Checksum Coverage</th>\n<th style=\"text-align: center;\">Coverage Area</th>\n<th style=\"text-align: center;\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">0</td>\n<td style=\"text-align: center;\">entire UDP-Lites datagram</td>\n<td style=\"text-align: center;\">Calculation covers IP pseudo-header</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">1-7</td>\n<td style=\"text-align: center;\">(invalid)</td>\n<td style=\"text-align: center;\">The receiver has to drop the datagram</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">8</td>\n<td style=\"text-align: center;\">UDP-Lites header</td>\n<td style=\"text-align: center;\">Calculation covers IP pseudo-header</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">&gt; 8</td>\n<td style=\"text-align: center;\">UDP-Lites header + portion of payload data</td>\n<td style=\"text-align: center;\">Calculation covers IP pseudo-header</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">&gt; IP datagram length</td>\n<td style=\"text-align: center;\">(invalid)</td>\n<td style=\"text-align: center;\">The receiver has to drop the datagram</td>\n</tr>\n</tbody>\n</table>\n<p>For multimedia applications running VoIP or streaming video data transmission protocols, it'd better receive data with some degree of corruption than not receiving any data at all. Another example is the <a href=\"https://tools.ietf.org/html/rfc5415\">CAPWAP</a> protocol used to connect Cisco wireless controller and access points. It specifies UDP-Lite as the default transport protocol for the CAPWAP Data channel, while the connection is established over IPv6 network.</p>\n<p>At last, share a C program snippet to present how to initialize a Berkeley socket to establish an IPv6 UDP-Lite connection:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;net/udplite.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> udplite_conn = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDPLITE);</span><br><span class=\"line\"><span class=\"keyword\">int</span> val = <span class=\"number\">8</span>;    <span class=\"comment\">/* checksum only covers 8-byte UDP-Lite header */</span></span><br><span class=\"line\">(<span class=\"keyword\">void</span>)setsockopt(udplite_conn, IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV, &amp;val, <span class=\"keyword\">sizeof</span> val);</span><br><span class=\"line\">(<span class=\"keyword\">void</span>)setsockopt(udplite_conn, IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV, &amp;val, <span class=\"keyword\">sizeof</span> val);</span><br></pre></td></tr></table></figure>\n<p>Here <code>IPPROTO_UDPLITE</code> is protocol number 136, which is used together with <code>AF_INET6</code> address family paramater in <code>socket()</code> funtion call for IPv6 socket creation. The <code>UDPLITE_SEND_CSCOV</code>(10) and <code>UDPLITE_RECV_CSCOV</code>(11) are the control parameters of socket option configuration function <code>setsockopt()</code>, used for setting the Checksum Coverage value in the sender and the receiver respectively. Remember that both the sender and the receiver must set the same value, otherwise the receiver will not be able to verify the checksum properly.</p>\n","categories":["Study Notes"],"tags":["TCP/IP","C/C++ Programming"]},{"title":"Understand Endianness","url":"/en/2021-12-24-Endianness.html","content":"<p>The problem of Endianness is essentially a question about how computers store large numbers. <span id=\"more\"></span></p>\n<div class=\"note success no-icon\"><p><strong>I do not fear computers. I fear lack of them.</strong><br> <strong>— <em>Isaac Asimov</em> (American writer and professor of biochemistry, best known for his hard science fiction)</strong></p>\n</div>\n<p>We know that one basic memory unit can hold one byte, and each memory unit has its own address. For an integer larger than decimal 255 (0xff in hexadecimal), more than one memory unit is required. For example, 4660 is 0x1234 in hexadecimal and requires two bytes. Different computer systems use different methods to store these two bytes. In our common PC, the least-significant byte 0x34 is stored in the low address memory unit and the most-significant byte 0x12 is stored in the high address memory unit. While in Sun workstations, the opposite is true, with 0x34 in the high address memory unit and 0x12 in the low address memory unit. The former is called <code>Little Endian</code> and the latter is <code>Big Endian</code>.</p>\n<p>How can I remember these two data storing modes? It is actually quite simple. First remember that the addresses of the memory units we are talking about are always arranged from low to high. For a multi-byte number, if the first byte in the low address you see is the least-significant byte, the system is <code>Little Endian</code>, where Little matchs <code>low</code>. On the contrary is <code>Big Endian</code>, where Big corresponds to \"high\".</p>\n<h2 id=\"program-example\">Program Example</h2>\n<p>To deepen our understanding of Endianness, let's look at the following example of a C program:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a = <span class=\"number\">1</span>; \t \t \t </span><br><span class=\"line\"><span class=\"keyword\">char</span> b = <span class=\"number\">2</span>;                       </span><br><span class=\"line\"><span class=\"keyword\">short</span> c = <span class=\"number\">255</span>;\t<span class=\"comment\">/* 0x00ff */</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> d = <span class=\"number\">0x44332211</span>;</span><br></pre></td></tr></table></figure>\n<p>On Intel 80x86 based systems, the memory content corresponding to variables a, b, c, and d are shown in the following table：</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>Address Offset</th>\n<th>Memory Content</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>0x0000</td>\n<td>01 02 FF 00</td>\n</tr>\n<tr class=\"even\">\n<td>0x0004</td>\n<td>11 22 33 44</td>\n</tr>\n</tbody>\n</table>\n<p>Obviously we can immediately tell that this system is <code>Little Endian</code>. For a 16-bit integer <code>short c</code>, we see the least-significant byte 0xff first, and the next one is 0x00. Similarly for a 32-bit integer <code>long d</code>, the least-significant byte 0x11 is stored at the lowest address 0x0004. If this is in a <code>Big Endian</code> computer, memory content would be: <em>01 02 00 FF 44 33 22 11</em>.</p>\n<p>At run time all computer processors must choose between these two Endians. The following is a short list of processor types with supported Endian modes:</p>\n<ul>\n<li>Pure<code>Big Endian</code>: Sun SPARC, Motorola 68000，Java Virtual Machine</li>\n<li>Bi-Endian running <code>Big Endian</code> mode: MIPS with IRIX, PA-RISC, most Power and PowerPC systems</li>\n<li>Bi-Endian running <code>Little Endian</code> mode: ARM, MIPS with Ultrix, most DEC Alpha, IA-64 with Linux</li>\n<li><code>Little Endian</code>: Intel x86, AMD64, DEC VAX</li>\n</ul>\n<p>How to detect the Endianess of local system in the program? The following function can be called for a quick check. If the return value is 1, it is <code>Little Endian</code>, else <code>Big Endian</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">test_endian</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *((<span class=\"keyword\">char</span> *)&amp;x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"network-order\">Network Order</h2>\n<p>Endianness is also important for computer communications. Imagining that when a <code>Little Endian</code> system communicates with a <code>Big Endian</code> system, the receiver and sender will interpret the data completely differently if not handled properly. For example, for the variable d in the C program segment above, the <code>Little Endian</code> sender sends <em>11 22 33 44</em> four bytes, which the <code>Big Endian</code> receiver converts to the value 0x11223344. This is very different from the original value. To solve this problem, the TCP/IP protocol specifies a special \"network byte order\" (referred to as \"network order\"), which means that regardless of the Endian supported by the computer system, the most-significant byte is always sent first while transmitting data. From the definition, we can see that the network order actually corresponds to the <code>Big Endian</code>.</p>\n<p>In order to avoid communication problems caused by Endianness and to facilitate software developers to write portable programs, some C preprocessing macros are defined for conversion between network bytes and local byte order. <code>htons()</code> and <code>htonl()</code> are used to convert local byte order to network byte order, the former works with 16-bit unsigned numbers and the latter for 32-bit unsigned numbers. <code>ntohs()</code> and <code>ntohl()</code> implement the conversion in the opposite direction. The prototype definitions of these four macros can be found as follows (available in the <code>netinet/in.h</code> file on Linux systems).</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(BIG_ENDIAN) &amp;&amp; !defined(LITTLE_ENDIAN)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> htons(A)  (A)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> htonl(A)  (A)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ntohs(A)  (A)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ntohl(A)  (A)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> defined(LITTLE_ENDIAN) &amp;&amp; !defined(BIG_ENDIAN)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> htons(A)  ((((uint16)(A) &amp; 0xff00) &gt;&gt; 8) | \\</span></span><br><span class=\"line\"><span class=\"meta\">                   (((uint16)(A) &amp; 0x00ff) &lt;&lt; 8))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> htonl(A)  ((((uint32)(A) &amp; 0xff000000) &gt;&gt; 24) | \\</span></span><br><span class=\"line\"><span class=\"meta\">                   (((uint32)(A) &amp; 0x00ff0000) &gt;&gt; 8)  | \\</span></span><br><span class=\"line\"><span class=\"meta\">                   (((uint32)(A) &amp; 0x0000ff00) &lt;&lt; 8)  | \\</span></span><br><span class=\"line\"><span class=\"meta\">                   (((uint32)(A) &amp; 0x000000ff) &lt;&lt; 24))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ntohs     htons</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ntohl     htohl</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">error</span> <span class=\"meta-string\">&quot;Either BIG_ENDIAN or LITTLE_ENDIAN must be #defined, but not both.&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n","categories":["Study Notes"],"tags":["C/C++ Programming","Computer Architecture","Computer Communications","System Programming"]}]