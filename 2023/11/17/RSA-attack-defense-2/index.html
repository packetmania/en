<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 6.3.0">

<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/en/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="piAnQ_mnwkhV_qh4_Se1yLzM1IwOvuq-vmYfXBkWRXU">

<link rel="stylesheet" href="/en/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=EB+Garamond:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.packetmania.net","root":"/en/","images":"/en/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk | utterances | disqus","storage":true,"lazyload":false,"nav":{"disqus":{"text":"Disqus Comments","order":-1},"utterances":{"text":"Utterances Comments","order":-2},"gitalk":{"text":"Gitalk Comments","order":-3}}},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script>
<meta name="description" content="This article first supplements two specific integer factorization methods - Fermat&#39;s factorization method and Pollard&#39;s rho algorithm, explaining the essence of their algorithms and applicable scenari">
<meta property="og:type" content="article">
<meta property="og:title" content="RSA: Attack and Defense (II)">
<meta property="og:url" content="https://www.packetmania.net/en/2023/11/17/RSA-attack-defense-2/index.html">
<meta property="og:site_name" content="PacketMania">
<meta property="og:description" content="This article first supplements two specific integer factorization methods - Fermat&#39;s factorization method and Pollard&#39;s rho algorithm, explaining the essence of their algorithms and applicable scenari">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.packetmania.net/en/2023/11/17/RSA-attack-defense-2/Pollard_rho_cycle.png">
<meta property="article:published_time" content="2023-11-18T03:37:22.829Z">
<meta property="article:modified_time" content="2023-11-19T21:07:00.761Z">
<meta property="article:author" content="Zixi">
<meta property="article:tag" content="Cryptography">
<meta property="article:tag" content="Network Security">
<meta property="article:tag" content="Python Programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.packetmania.net/en/2023/11/17/RSA-attack-defense-2/Pollard_rho_cycle.png">


<link rel="canonical" href="https://www.packetmania.net/en/2023/11/17/RSA-attack-defense-2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.packetmania.net/en/2023/11/17/RSA-attack-defense-2/","path":"2023/11/17/RSA-attack-defense-2/","title":"RSA: Attack and Defense (II)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>RSA: Attack and Defense (II) | PacketMania</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-9YKBP0QK7Z"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-9YKBP0QK7Z","only_pageview":false}</script>
  <script src="/en/js/third-party/analytics/google-analytics.js"></script>




  <noscript>
    <link rel="stylesheet" href="/en/css/noscript.css">
  </noscript>
<link rel="alternate" href="/en/atom.xml" title="PacketMania" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/en/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">PacketMania</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Technology | Knowledge | Sharing</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/en/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/en/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
        <li class="menu-item menu-item-rss"><a href="/en/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a></li>
        <li class="menu-item menu-item-language"><a href="https://www.packetmania.net/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#integer-factorization-supplementary"><span class="nav-number">1.</span> <span class="nav-text">Integer Factorization (Supplementary)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fermats-factorization-method"><span class="nav-number">1.1.</span> <span class="nav-text">Fermat&#39;s Factorization Method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pollards-rho-algorithm"><span class="nav-number">1.2.</span> <span class="nav-text">Pollard&#39;s Rho Algorithm</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#low-private-exponent-attack"><span class="nav-number">2.</span> <span class="nav-text">Low Private Exponent Attack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#wieners-attack"><span class="nav-number">2.1.</span> <span class="nav-text">Wiener&#39;s Attack</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#continued-fraction"><span class="nav-number">2.1.1.</span> <span class="nav-text">Continued Fraction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#attack-mechanism"><span class="nav-number">2.1.2.</span> <span class="nav-text">Attack Mechanism</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#attack-workflow"><span class="nav-number">2.1.3.</span> <span class="nav-text">Attack Workflow</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zixi"
      src="/en/images/ccie.gif">
  <p class="site-author-name" itemprop="name">Zixi</p>
  <div class="site-description" itemprop="description">Computer Networking and Software Design & Implementation</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/en/archives/">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/en/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/en/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/packetmania" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;packetmania" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zixiruoxue@gmail.com" title="E-Mail → mailto:zixiruoxue@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/zixisean" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;zixisean" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/15140531" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;15140531" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_nd.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.packetmania.net/en/2023/11/17/RSA-attack-defense-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/en/images/ccie.gif">
      <meta itemprop="name" content="Zixi">
      <meta itemprop="description" content="Computer Networking and Software Design & Implementation">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PacketMania">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RSA: Attack and Defense (II)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-17 19:37:22" itemprop="dateCreated datePublished" datetime="2023-11-17T19:37:22-08:00">2023-11-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-11-19 13:07:00" itemprop="dateModified" datetime="2023-11-19T13:07:00-08:00">2023-11-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/en/categories/Technical-Know-how/" itemprop="url" rel="index"><span itemprop="name">Technical Know-how</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Symbols count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Symbols count in article: </span>
      <span>27k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>25 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>This article first supplements two specific integer factorization methods - Fermat's factorization method and Pollard's rho algorithm, explaining the essence of their algorithms and applicable scenarios, and provides a Python reference implementation. Next, it analyzes in detail a classic low private exponent attack - Wiener's attack, elaborating on the mathematical basis, the attack principle, and the attack procedure, with a complete Python program. The article also cites the latest research paper proposing a new upper bound for the private exponent when Wiener's attack is successful and verifies the correctness of this limit with a test case.<span id="more"></span></p>
<div class="note success no-icon"><p><strong>The enemy knows the system being used.</strong><br> <strong>— <em>Claude Shannon</em> (American mathematician, electrical engineer, computer scientist, and cryptographer known as the "father of information theory".)</strong></p>
</div>
<p>Previous article: <a href="https://www.packetmania.net/en/2023/03/16/RSA-attack-defense/">RSA: Attack and Defense (I)</a></p>
<h2 id="integer-factorization-supplementary">Integer Factorization (Supplementary)</h2>
<p>Even if the RSA modulus <span class="math inline">\(N\)</span> is a very big number (with sufficient bits), problems can still arise if the gap between the prime factors <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> is too small or too large. In such cases, there are specific factorization algorithms that can effectively retrieve p and q from the public modulus N.</p>
<h3 id="fermats-factorization-method">Fermat's Factorization Method</h3>
<p>When the prime factors <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> are very close, Fermat's factorization method can factorize the modulus N in a very short time. Fermat's factorization method is named after the French mathematician <a href="https://www.packetmania.net/en/2023/11/14/Fermats-Little-Theorem//">Pierre de Fermat</a>. Its base point is that every odd integer can be represented as the difference between two squares, i.e. <span class="math display">\[N=a^2-b^2\]</span> Applying algebraic factorization on the right side yields <span class="math inline">\((a+b)(a-b)\)</span>. If neither factor is one, it is a nontrivial factor of <span class="math inline">\(N\)</span>. For the RSA modulus <span class="math inline">\(N\)</span>, assuming <span class="math inline">\(p&gt;q\)</span>, correspondingly <span class="math inline">\(p=a+b\)</span> and <span class="math inline">\(q=a-b\)</span>. In turn, it can be deduced that <span class="math display">\[N=\left({\frac {p+q}{2}}\right)^{2}-\left({\frac {p-q}{2}}\right)^{2}\]</span> The idea of Fermat's factorization method is to <strong>start from <span class="math inline">\(\lceil{\sqrt N}\rceil\)</span> and try successive values of a, then verify if <span class="math inline">\(a^{2}-N=b^{2}\)</span></strong>. If it is true, the two nontrivial factors <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> are found. The number of steps required by this method is approximately <span class="math display">\[{\frac{p+q}{2}}-{\sqrt N}=\frac{({\sqrt p}-{\sqrt q})^{2}}{2}=\frac{({\sqrt N}-q)^{2}}{2q}\]</span> In general, Fermat's factorization method is not much better than trial division. In the worst case, it may be slower. However, <strong>when the difference between <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> is not large, and <span class="math inline">\(q\)</span> is very close to <span class="math inline">\(\sqrt N\)</span>, the number of steps becomes very small</strong>. In the extreme case, if the difference between <span class="math inline">\(q\)</span> and <span class="math inline">\(\sqrt N\)</span> is less than <span class="math inline">\({\left(4N\right)}^{\frac 1 4}\)</span>, this method only takes one step to finish.</p>
<p>Below is a Python implementation of Fermat's factorization method, and an example of applying it to factorize the RSA modulus N:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FermatFactor</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">assert</span> n % <span class="number">2</span> != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    a = gmpy2.isqrt(n) + <span class="number">1</span></span><br><span class="line">    b2 = gmpy2.square(a) - n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> gmpy2.is_square(b2):</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        b2 = gmpy2.square(a) - n</span><br><span class="line"></span><br><span class="line">    b = gmpy2.isqrt(b2)</span><br><span class="line">    <span class="keyword">return</span> a + b, a - b</span><br><span class="line"></span><br><span class="line">p = <span class="number">7422236843002619998657542152935407597465626963556444983366482781089760760914403641211700959458736191688739694068306773186013683526913015038631710959988771</span></span><br><span class="line">q = <span class="number">7422236843002619998657542152935407597465626963556444983366482781089760759017266051147512413638949173306397011800331344424158682304439958652982994939276427</span></span><br><span class="line">N = p * q</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;N =&quot;</span>, N)</span><br><span class="line"></span><br><span class="line">start = time.process_time()</span><br><span class="line">(p1, q1) = FermatFactor(N)</span><br><span class="line">end = time.process_time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Elapsed time <span class="subst">&#123;end - start:<span class="number">.3</span>f&#125;</span>s.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(p == p1)</span><br><span class="line"><span class="keyword">assert</span>(q == q1)</span><br></pre></td></tr></table></figure>
<p>The <code>FermatFactor()</code> function defined at the beginning of the program implements the Fermat factorization method. It calls three library functions of gmpy2: <code>isqrt()</code> to find the square root of an integer, <code>square()</code> to execute the squaring operation, and <code>is_square()</code> to verify if the input is a square number. Two large prime numbers <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> of 154 decimal digits each are defined later, and multiplying them gives <span class="math inline">\(N\)</span>. Then <span class="math inline">\(N\)</span> is fed into the <code>FermatFactor()</code> function and the program starts timing. When the function returns, it prints the elapsed time and confirms the factorization.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">N = 55089599753625499150129246679078411260946554356961748980861372828434789664694269460953507615455541204658984798121874916511031276020889949113155608279765385693784204971246654484161179832345357692487854383961212865469152326807704510472371156179457167612793412416133943976901478047318514990960333355366785001217</span><br><span class="line">Elapsed time 27.830s.</span><br></pre></td></tr></table></figure>
<p>As can be seen, in less than half a minute, this large number of 308 decimal digits (about 1024 bits) was successfully factorized! Going back and examining <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>, one can see that the first 71 digits of these two large prime numbers of 154 decimal digits are exactly the same. This is exactly the scenario in which the Fermat factorization method exerts its power. If you simply modify the <code>FermatFactor()</code> function to save the starting <span class="math inline">\(a\)</span> value and compare it to the value at the end of the loop, you get a loop count of 60613989. With such a small number value, it's no wonder that the factorization is done so quickly.</p>
<p>Therefore, the choice of the large prime numbers <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> must not only be random but also be far enough apart. After obtaining two large prime numbers, the difference between them shall be checked. If it is too small, regeneration is required to prevent attackers from using Fermat's factorization method to crack it.</p>
<h3 id="pollards-rho-algorithm">Pollard's Rho Algorithm</h3>
<p>On the opposite end, if the gap between the large prime factors <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> is too large, they may be cracked by Pollard's rho algorithm. This algorithm was invented by British mathematician John Pollard<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> in 1975. It requires only a small amount of storage space, and its expected running time is proportional to the square root of the smallest prime factor of the composite number being factorized.</p>
<p>The core idea of Pollard's rho algorithm is to use the collision pattern of traversal sequences to search for factors, and its stochastic and recursive nature allows it to factorize integers efficiently in relatively low complexity. First, for <span class="math inline">\(N=pq\)</span>, assume that <span class="math inline">\(p\)</span> is the smaller nontrivial factor. The algorithm defines a polynomial modulo <span class="math inline">\(N\)</span> <span class="math display">\[f(x)=(x^{2}+c){\pmod N}\]</span> A pseudorandom sequence can be generated by making recursive calls with this polynomial, and the sequence generation formula is <span class="math inline">\(x_{n+1}=f(x_n)\)</span>. For example, given an initial value of <span class="math inline">\(x_0=2\)</span> and a constant <span class="math inline">\(c=1\)</span>, it follows that <span class="math display">\[\begin{align}
x_1&amp;=f(2)=5\\
x_2&amp;=f(x_1)=f(f(2))=26\\
x_3&amp;=f(x_2)=f(f(f(2)))=677\\
\end{align}\]</span> For two numbers <span class="math inline">\(x_i\)</span> and <span class="math inline">\(x_j\)</span> in the generated sequence, <span class="math inline">\(|x_i-x_j|\)</span> must be a multiple of <span class="math inline">\(p\)</span> if <span class="math inline">\(x_i\neq x_j\)</span> and <span class="math inline">\(x_i\equiv x_j{\pmod p}\)</span>. In this case, calculating <span class="math inline">\(\gcd(|x_i-x_j|,N)\)</span> results in <span class="math inline">\(p\)</span>. Based on the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Birthday_problem">Birthday Paradox</a>, in the worst case, it is expected that after generating about <span class="math inline">\(\sqrt p\)</span> numbers, there will be two numbers that are the same under the modulus <span class="math inline">\(p\)</span>, thus successfully factorizing <span class="math inline">\(N\)</span>. However, the time complexity of performing pairwise comparisons is still unsatisfactory. In addition, storing so many numbers is also troublesome when N is large.</p>
<p>How to solve these problems? This is where the ingenuity of Pollard's rho algorithm lies. Pollard found that the sequence generated by this pseudorandom number generator has two properties:</p>
<ol type="1">
<li>Since each number depends only on the value that precedes it, and the numbers generated under the modular operation are finite, sooner or later it will enter a cycle. As shown below, the resulting sequence will eventually form a directed graph similar in shape to the Greek letter <span class="math inline">\(\rho\)</span>, from which the algorithm takes its name. <img src="Pollard_rho_cycle.png" style="width:50.0%;height:50.0%" alt="Cycle diagram resembling the Greek letter ρ" /></li>
<li>When <span class="math inline">\(|x_i-x_j| \equiv 0 \pmod p\)</span>, there must be <span class="math display">\[|f(x_i)-f(x_j)|=|{x_i}^2-{x_j}^2|=|x_i+x_j|\cdot|x_i-x_j|\equiv 0 \pmod p\]</span> This shows that if two numbers in the sequence satisfy a certain condition under modulus operation, all equally spaced pairs of numbers satisfy the same condition.</li>
</ol>
<p>Insightful of these two properties, Pollard utilizes <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cycle_detection#Floyd&#39;s_tortoise_and_hare">Floyd's cycle-finding algorithm</a> (also known as the tortoise and hare algorithm) to set up the fast and slow nodes <span class="math inline">\(x_h\)</span> and <span class="math inline">\(x_t\)</span>. Starting from the same initial value <span class="math inline">\(x_0\)</span>, the slow node <span class="math inline">\(x_t\)</span> moves to the next node in the sequence every step, while the fast node <span class="math inline">\(x_h\)</span> moves forward by two nodes at a time, i.e. <span class="math display">\[\begin{align}
x_t&amp;=f(x_t)\\
x_h&amp;=f(f(x_h))\\
\end{align}\]</span> After that, calculate <span class="math inline">\(\gcd(|x_h-x_t|,N)\)</span>, and the result that is greater than 1 and less than <span class="math inline">\(N\)</span> is <span class="math inline">\(p\)</span>, otherwise continue with the same steps. With this design, since each move is equivalent to checking a new node spacing, pairwise comparisons are unnecessary. If not found, eventually the fast and slow nodes will meet on the cycle, at which time the result of finding the greatest common divisor is <span class="math inline">\(N\)</span>. The algorithm's recommendation at this point is to exit and regenerate the pseudorandom number sequence with a different initial value or constant <span class="math inline">\(c\)</span> and try again.</p>
<p>This is the classic Pollard's rho algorithm. Its time complexity is <span class="math inline">\(𝑂(\sqrt p\log N)\)</span> (<span class="math inline">\(\log\)</span> comes from the required <span class="math inline">\(\gcd\)</span> operations). For RSA modulus <span class="math inline">\(N\)</span>, obviously <span class="math inline">\(p\leq \sqrt N\)</span>, so the upper bound on the time complexity can be written as <span class="math inline">\(𝑂(N^{\frac 1 4}\log N)\)</span>. The time complexity expression for Pollard's rho algorithm indicates that the smaller the minimum prime factor of the composite number being factorized, the faster the factorization is expected to be. An excessively small <span class="math inline">\(p\)</span> is extremely unsafe.</p>
<p>Programming Pollard's rho algorithm is not difficult. The following Python code shows a function implementation of the algorithm, <code>PollardRhoFactor()</code>, and some test cases</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PollardRhoFactor</span>(<span class="params">n, seed, c</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> gmpy2.is_prime(n): <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        f = <span class="keyword">lambda</span> x: (x**<span class="number">2</span> + c) % n</span><br><span class="line">        t = h = seed</span><br><span class="line">        d = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> d == <span class="number">1</span>:</span><br><span class="line">            t = f(t)    <span class="comment"># Tortoise</span></span><br><span class="line">            h = f(f(h)) <span class="comment"># Hare</span></span><br><span class="line">            d = gmpy2.gcd(h - t, n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> d != n:</span><br><span class="line">            <span class="keyword">return</span> d <span class="comment"># find a non-trivial factor</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># start a new round with updated seed and c</span></span><br><span class="line">        seed = h</span><br><span class="line">        c += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">N = [<span class="number">10967535067</span>, <span class="number">18446744073709551617</span>, <span class="number">97546105601219326301</span>,</span><br><span class="line">     <span class="number">780002082420246798979794021150335143</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;N&#x27;</span>:&lt;<span class="number">37</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;P&#x27;</span>:&lt;<span class="number">16</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;Elapsed Time (s)&#x27;</span>:&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(N)):</span><br><span class="line">    start = time.process_time()</span><br><span class="line">    p = PollardRhoFactor(N[i], <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    end = time.process_time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;N[i]:&lt;<span class="number">37</span>&#125;</span><span class="subst">&#123;p:&lt;<span class="number">16</span>&#125;</span><span class="subst">&#123;end - start:<span class="number">16.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">F8 = <span class="number">2</span>**(<span class="number">2</span>**<span class="number">8</span>) + <span class="number">1</span> <span class="comment"># A 78-digit Fermat number</span></span><br><span class="line">start = time.process_time()</span><br><span class="line">p = PollardRhoFactor(F8, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">end = time.process_time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;\nF8 = <span class="subst">&#123;F8&#125;</span>\np = <span class="subst">&#123;p&#125;</span>\nElapsed time <span class="subst">&#123;end - start:<span class="number">.3</span>f&#125;</span>s&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>The function <code>PollardRhoFactor()</code> accepts three arguments: <code>n</code> is the composite number to be factorized, <code>seed</code> is the initial value of the pseudorandom sequence, and <code>c</code> is the constant value in the generating polynomial. The function internally uses two <code>while</code> to form a double loop: inside the outer loop defines the generating polynomial <code>f</code> and the fast and slow nodes <code>h</code> and <code>t</code>, while the node moving steps and the greatest common divisor operation are implemented in the inner loop. The inner loop ends only if the greatest common divisor <code>d</code> is not 1. At this point, if <code>d</code> is not equal to <code>n</code>, the function returns the non-trivial factor <code>d</code>. Otherwise, <code>d</code> equals <code>n</code>, meaning the fast and slow nodes have met on the cycle. In this situation, the code in the outer loop resets <code>seed</code> to the value of the fast node and increments <code>c</code>, thus restarting a new round of search.</p>
<p>Running the above code on a MacBook Pro (2019), the output is as follows</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">N                                    P               Elapsed Time (s)</span><br><span class="line">10967535067                          104729                     0.001</span><br><span class="line">18446744073709551617                 274177                     0.002</span><br><span class="line">97546105601219326301                 9876543191                 0.132</span><br><span class="line">780002082420246798979794021150335143 244300526707007            6.124</span><br><span class="line"></span><br><span class="line">F8 = 115792089237316195423570985008687907853269984665640564039457584007913129639937</span><br><span class="line">p = 1238926361552897</span><br><span class="line">Elapsed time 64.411s</span><br></pre></td></tr></table></figure>
<p>This result proves the effectiveness of Pollard's rho algorithm. In particular, for the last test, the input to the function was the Fermat number <span class="math inline">\(F_8\)</span> (defined as <span class="math inline">\(F_{n}=2^{2^{n}}+1\)</span>, where <span class="math inline">\(n\)</span> is a non-negative integer). In 1980, Pollard and Australian mathematician Richard Brent <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> working together applied this algorithm to factorize <span class="math inline">\(F_8\)</span> for the first time. The factorization took 2 hours on a UNIVAC 1100/42 computer. And now, on a commercial off-the-shelf laptop computer, Pollard's rho algorithm revealed the smaller prime factor 1238926361552897 of <span class="math inline">\(F_8\)</span> in 64.4 seconds.</p>
<p>Subsequently, Pollard and Brent made further improvements to the algorithm. They observed that if <span class="math inline">\(\gcd(d, N)&gt;1\)</span>, for any positive integer <span class="math inline">\(k\)</span>, there is also <span class="math inline">\(\gcd(kd, N)&gt;1\)</span>. So multiplying <span class="math inline">\(k\)</span> consecutive <span class="math inline">\((|x_h-x_t| \pmod N)\)</span> and taking the modulo <span class="math inline">\(N\)</span> with the product, and then solving for the greatest common divisor with <span class="math inline">\(N\)</span> should obtain the same result. This method replaces <span class="math inline">\(k\)</span> times <span class="math inline">\(\gcd\)</span> with <span class="math inline">\((k-1)\)</span> times multiplications modulo <span class="math inline">\(N\)</span> and a single <span class="math inline">\(\gcd\)</span>, thus achieving acceleration. The downside is that occasionally it may cause the algorithm to fail by introducing a repeated factor. When this happens, it then suffices to reset <span class="math inline">\(k\)</span> to 1 and fall back to the regular Pollard's rho algorithm.</p>
<p>The following Python function implements the improved Pollard's rho algorithm. It adds an extra <code>for</code> loop to implement the multiplication of <span class="math inline">\(k\)</span> consecutive differences modulo <span class="math inline">\(N\)</span>, with the resulting product stored in the variable <code>mult</code>. <code>mult</code> is fed to the greatest common divisor function with <span class="math inline">\(N\)</span>, and the result is assigned to <code>d</code> for further check. If this fails, <span class="math inline">\(k\)</span> is set to 1 in the outer loop.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">PollardRhoFactor2</span>(<span class="params">n, seed, c, k</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> gmpy2.is_prime(n): <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        f = <span class="keyword">lambda</span> x: (x**<span class="number">2</span> + c) % n</span><br><span class="line">        t = h = seed</span><br><span class="line">        d = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> d == <span class="number">1</span>:</span><br><span class="line">            mult = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                t = f(t)    <span class="comment"># Tortoise</span></span><br><span class="line">                h = f(f(h)) <span class="comment"># Hare</span></span><br><span class="line">                mult = (mult * <span class="built_in">abs</span>(h - t)) % n</span><br><span class="line">                </span><br><span class="line">            d = gmpy2.gcd(mult, n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> d != n:</span><br><span class="line">            <span class="keyword">return</span> d <span class="comment"># find a non-trivial factor</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># start a new round with updated seed and c</span></span><br><span class="line">        seed = h</span><br><span class="line">        c += <span class="number">1</span></span><br><span class="line">        k = <span class="number">1</span> <span class="comment"># fall back to regular rho algorithm</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;N&#x27;</span>:&lt;<span class="number">37</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;P&#x27;</span>:&lt;<span class="number">16</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;Elapsed Time (s)&#x27;</span>:&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(N)):</span><br><span class="line">    start = time.process_time()</span><br><span class="line">    p = PollardRhoFactor2(N[i], <span class="number">2</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    end = time.process_time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;N[i]:&lt;<span class="number">37</span>&#125;</span><span class="subst">&#123;p:&lt;<span class="number">16</span>&#125;</span><span class="subst">&#123;end - start:<span class="number">16.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">F8 = <span class="number">2</span>**(<span class="number">2</span>**<span class="number">8</span>) + <span class="number">1</span> <span class="comment"># A 78-digit Fermat number</span></span><br><span class="line">start = time.process_time()</span><br><span class="line">p = PollardRhoFactor2(F8, <span class="number">2</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">end = time.process_time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;\nF8 = <span class="subst">&#123;F8&#125;</span>\np = <span class="subst">&#123;p&#125;</span>\nElapsed time <span class="subst">&#123;end - start:<span class="number">.3</span>f&#125;</span>s&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>Using the same test case, called with <span class="math inline">\(k\)</span> set to 100, the program runs as follows</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">N                                    P               Elapsed Time (s)</span><br><span class="line">10967535067                          104729                     0.001</span><br><span class="line">18446744073709551617                 274177                     0.002</span><br><span class="line">97546105601219326301                 9876543191                 0.128</span><br><span class="line">780002082420246798979794021150335143 244300526707007            5.854</span><br><span class="line"></span><br><span class="line">F8 = 115792089237316195423570985008687907853269984665640564039457584007913129639937</span><br><span class="line">p = 1238926361552897</span><br><span class="line">Elapsed time 46.601s</span><br></pre></td></tr></table></figure>
<p>It can be seen that for relatively small composite <span class="math inline">\(N\)</span>, the improvement is not significant. As <span class="math inline">\(N\)</span> becomes larger, the speedup is noticeable. For the 78-bit decimal Fermat number <span class="math inline">\(F_8\)</span>, the improved Pollard's rho algorithm takes only 46.6 seconds, which is a speedup of more than 27% over the regular algorithm. The improved Pollard <span class="math inline">\(\rho\)</span> algorithm indeed brings significant speedup.</p>
<p>To summarize the above analysis, implementation, and testing of Pollard's rho algorithm, it is necessary to set a numerical lower bound for the generated prime numbers <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> to be used by RSA. If either of them is too small, it must be regenerated or it may be cracked by an attacker applying Pollard's rho algorithm.</p>
<h2 id="low-private-exponent-attack">Low Private Exponent Attack</h2>
<p>For some particular application scenarios (e.g., smart cards and IoT), limited by the computational capability and low-power requirements of the device, a smaller value of private exponent <span class="math inline">\(d\)</span> is favored for fast decryption or digital signing. However, a very low private exponent is very dangerous, and there are some clever attacks that can totally breach such an RSA cryptosystem.</p>
<h3 id="wieners-attack">Wiener's Attack</h3>
<p>In 1990, Canadian cryptographer Michael J. Wiener conceived an attack scheme<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> based on <strong>continued fraction approximation</strong> that can effectively recover the private exponent <span class="math inline">\(d\)</span> from the RSA public key <span class="math inline">\((N, e)\)</span> under certain conditions. Before explaining how this attack works, it is important to briefly introduce the concept and key properties of continued fraction.</p>
<h4 id="continued-fraction">Continued Fraction</h4>
<p>The continuous fraction itself is just a mathematical expression, but it introduces a new perspective on the study of real numbers. The following is a typical continued fraction <span class="math display">\[x = a_0 + \cfrac{1}{a_1 + \cfrac{1}{a_2 + \cfrac{1}{\ddots\,}}}\]</span> where <span class="math inline">\(a_{0}\)</span> is an integer and all other <span class="math inline">\(a_{i}(i=1,\ldots ,n)\)</span> are positive integers. One can abbreviate the continued fraction as <span class="math inline">\(x=[a_0;a_1,a_2,\ldots,a_n]\)</span>. Continued fractions have the following properties:</p>
<ol type="1">
<li><p>Every rational number can be expressed as a finite continued fraction, i.e., a finite number of <span class="math inline">\(a_{i}\)</span>. Every rational number has an essentially unique simple continued fraction representation with infinite terms. Here are two examples: <span class="math display">\[\begin{align}
\frac {68} {75}​&amp;=0+\cfrac {1} {1+\cfrac {1} {\small 9+\cfrac {1} {\scriptsize 1+\cfrac {1} {2+\cfrac {1} {2}}}}}=[0;1,9,1,2,2]\\
π&amp;=[3;7,15,1,292,1,1,1,2,…]
\end{align}\]</span></p></li>
<li><p>To calculate the continued fraction representation of a positive rational number <span class="math inline">\(f\)</span>, first subtract the integer part of <span class="math inline">\(f\)</span>, then find the reciprocal of the difference and repeat till the difference is zero. Let <span class="math inline">\(a_i\)</span> be the integer quotient, <span class="math inline">\(r_i\)</span> be the difference of the <span class="math inline">\(i\)</span>th step, and <span class="math inline">\(n\)</span> be the number of steps, then <span class="math display">\[\begin{align}
a_0 &amp;= \lfloor f \rfloor,  &amp;r_0 &amp;= f - a_0\\
a_i&amp;={\large\lfloor} \frac 1 {r_{i-1}} {\large\rfloor}, &amp;r_i &amp;=\frac 1 {r_{i-1}} - a_i \quad (i = 1, 2, ..., n)\\
\end{align}\]</span> The corresponding Python function implementing the continued fraction expansion of rationals is as follows</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cf_expansion</span>(<span class="params">nm: <span class="built_in">int</span>, dn:<span class="built_in">int</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Continued Fraction Expansion of Rationals</span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        nm - nominator</span></span><br><span class="line"><span class="string">        dn - denomainator</span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        List for the abbreviated notation of the continued fraction</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cf = []</span><br><span class="line">    a, r = nm // dn, nm % dn</span><br><span class="line">    cf.append(a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> r != <span class="number">0</span>:</span><br><span class="line">        nm, dn = dn, r</span><br><span class="line">        a = nm // dn</span><br><span class="line">        r = nm % dn</span><br><span class="line">        cf.append(a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cf</span><br></pre></td></tr></table></figure></p></li>
<li><p>For both rational and irrational numbers, the initial segments of their continued fraction representations produce increasingly accurate rational approximations. These rational numbers are called the convergents of the continued fraction. The even convergents continually increase, but are always less than the original number; while the odd ones continually decrease, but are always greater than the original number. Denote the numerator and denominator of the <span class="math inline">\(i\)</span>-th convergent as <span class="math inline">\(h_i\)</span> and <span class="math inline">\(k_i\)</span> respectively, and define <span class="math inline">\(h_{-1}=1,h_{-2}=0\)</span> and <span class="math inline">\(k_{-1}=0,k_{-2}=1\)</span>, then the recursive formula for calculating the convergents is <span class="math display">\[\begin{align}
\frac {h_0} {k_0} &amp;= [0] = \frac 0 1 = 0&lt;\frac {68}  {75}\\
\frac {h_1} {k_1} &amp;= [0;1] = \frac 1 1 = 1&gt;\frac {68}  {75}\\
\frac {h_2} {k_2} &amp;= [0;1,9] = \frac 9 {10}&lt;\frac {68}  {75}\\
\frac {h_3} {k_3} &amp;= [0;1,9,1] = \frac {10} {11}&gt;\frac {68}  {75}\\
\frac {h_4} {k_4} &amp;= [0;1,9,1,2] = \frac {29} {32}&lt;\frac {68}  {75}\\
\end{align}\]</span> It can be verified that these convergents satisfy the aforementioned property and are getting closer to the true value. The following Python function implements a convergent generator for a given concatenated fraction expansion, and it returns a tuple of objects consisting of the convergent's numerator and denominator.</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cf_convergent</span>(<span class="params">cf: <span class="built_in">list</span></span>) -&gt; (<span class="built_in">int</span>, <span class="built_in">int</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Calculates the convergents of a continued fraction</span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        cf - list for the continued fraction expansion</span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        A generator object of the convergent tuple</span></span><br><span class="line"><span class="string">        (numerator, denominator)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    nm = [] <span class="comment"># Numerator</span></span><br><span class="line">    dn = [] <span class="comment"># Denominators</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cf)):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            ni, di = cf[i], <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">            ni, di = cf[i]*cf[i-<span class="number">1</span>] + <span class="number">1</span>, cf[i]</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># i &gt; 1</span></span><br><span class="line">            ni = cf[i]*nm[i-<span class="number">1</span>] + nm[i-<span class="number">2</span>]</span><br><span class="line">            di = cf[i]*dn[i-<span class="number">1</span>] + dn[i-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        nm.append(ni)</span><br><span class="line">        dn.append(di)</span><br><span class="line">        <span class="keyword">yield</span> ni, di</span><br></pre></td></tr></table></figure></p></li>
<li><p>Regarding the convergents of continued fractions, there is also an important Legendre<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> theorem: Let <span class="math inline">\(a∈ \mathbb Z, b ∈ \mathbb Z^+\)</span> such that <span class="math display">\[\left\lvert\,f - \frac a b\right\rvert&lt; \frac 1 {2b^2}\]</span> then <span class="math inline">\(\frac a b\)</span> is a convergent of the continued fraction of <span class="math inline">\(f\)</span>.</p></li>
</ol>
<h4 id="attack-mechanism">Attack Mechanism</h4>
<p>Now analyze how Wiener's attack works. From the relationship between RSA public and private exponent <span class="math inline">\(ed\equiv 1 {\pmod {\varphi(N)}}\)</span>, it can be deduced that there exists an integer <span class="math inline">\(k\)</span> such that <span class="math display">\[ed - k\varphi(N) = 1\]</span> Dividing both sides by <span class="math inline">\(d\varphi(N)\)</span> gives <span class="math display">\[\left\lvert\frac e {\varphi(N)} - \frac k d\right\rvert = \frac 1 {d{\varphi(N)}}\]</span> Careful observation of this formula reveals that because <span class="math inline">\(\varphi(N)\)</span> itself is very large, and <span class="math inline">\(\gcd(k,d)=1\)</span>, <span class="math inline">\(\frac k d\)</span> is very close to <span class="math inline">\(\frac e {\varphi(N)}\)</span>. In addition, <span class="math display">\[\varphi(N)=(p-1)(q-1)=N-(p+q)+1\]</span> Its difference from <span class="math inline">\(N\)</span> is also relatively small. Therefore, <span class="math inline">\(\frac k d\)</span> and <span class="math inline">\(\frac e N\)</span> also do not differ by much. Since RSA's <span class="math inline">\((N,e)\)</span> are public, Wiener boldly conceived - <strong>if <span class="math inline">\(\pmb{\frac e N}\)</span> is expanded into a continued fraction, it is possible that <span class="math inline">\(\pmb{\frac k d}\)</span> is one of its convergents!</strong></p>
<p>So how to verify if a certain convergent is indeed <span class="math inline">\(\frac k d\)</span>? With <span class="math inline">\(k\)</span> and <span class="math inline">\(d\)</span>, <span class="math inline">\(\varphi (N)\)</span> can be calculated, thereby obtaining <span class="math inline">\((p+q)\)</span>. Since both <span class="math inline">\((p+q)\)</span> and <span class="math inline">\(pq\)</span> are known, constructing a simple quadratic equation<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> can solve for <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>. If their product equals <span class="math inline">\(N\)</span>, then <span class="math inline">\(k\)</span> and <span class="math inline">\(d\)</span> are correct and the attack succeeds.</p>
<p>What are the conditions for Wiener's attack to work? Referring to Legendre's theorem mentioned above, it can be deduced that if <span class="math display">\[\left\lvert\frac e N - \frac k d\right\rvert &lt; \frac 1 {2{d^2}}\]</span> then <span class="math inline">\(\frac k d\)</span> must be a convergent of <span class="math inline">\(\frac e N\)</span>. This formula can also be used to derive an upper bound of the private exponent d for a feasible attack. Wiener's original paper states the upper bound as <span class="math inline">\(N^{\frac 1 4}\)</span>, but without detailed analysis. In 1999, American cryptographer Dan Boneh<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> provided the first rigorous proof of the upper bound, showing that under the constraints <span class="math inline">\(q&lt;p&lt;2q\)</span> and <span class="math inline">\(e&lt;\varphi(N)\)</span>, Wiener's attack applies for <span class="math inline">\(d&lt;\frac 1 3 N^{\frac 1 4}\)</span>. In <a target="_blank" rel="noopener" href="https://ink.library.smu.edu.sg/cgi/viewcontent.cgi?article=8411&amp;context=sis_research">a new paper published in 2019</a>, several researchers at the University of Wollongong in Australia further expanded the upper bound under the same constraints to <span class="math display">\[d\leq \frac 1 {\sqrt[4]{18}} N^\frac 1 4=\frac 1 {2.06...}N^\frac 1 4\]</span></p>
<p>Note that for simplicity, the above analysis of Wiener's attack mechanism is based on the Euler phi function <span class="math inline">\(\varphi (N)\)</span>. In reality, RSA key pairs are often generated using the Carmichael function <span class="math inline">\(\lambda(N)\)</span>. The relationship between the two is: <span class="math display">\[\varphi (N)=\lambda(n)\cdot\gcd(p-1,q-1)\]</span> It can be proven that starting from <span class="math inline">\(ed≡1{\pmod{\lambda(N)}}\)</span>, the same conclusions can be reached. Interested readers may refer to Wiener's original paper for details.</p>
<h4 id="attack-workflow">Attack Workflow</h4>
<p>With an understanding of the mechanism of Wiener's attack, the attack workflow can be summarized as follows:</p>
<ol type="1">
<li>Expand <span class="math inline">\(\frac e N\)</span> into a continued fraction</li>
<li>Generate the sequence of successive convergents of this continued fraction.</li>
<li>Iteratively check each convergent's numerator <span class="math inline">\(k\)</span> and denominator <span class="math inline">\(d\)</span>:
<ul>
<li>If <span class="math inline">\(k\)</span> is zero, or <span class="math inline">\(d\)</span> is even, or <span class="math inline">\(ed\not\equiv 1 \pmod k\)</span>, skip this convergent.</li>
<li>Calculate <span class="math inline">\(\varphi (N) = \frac {ed-1} k\)</span>, and solve for the integer roots p and q of the quadratic equation <span class="math inline">\(x^2−(N−φ(N)+1)x+N\)</span>.</li>
<li>Verify if <span class="math inline">\(N = p \cdot q\)</span>, if true, the attack succeeds and return <span class="math inline">\((p, q, d)\)</span>; otherwise continue.</li>
<li>If all convergents are checked and no match, Wiener's attack fails.</li>
</ul></li>
</ol>
<p>The complete Python implementation is as follows:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve_rsa_primes</span>(<span class="params">s: <span class="built_in">int</span>, m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">tuple</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Solve RSA prime numbers (p, q) from the quadratic equation</span></span><br><span class="line"><span class="string">    p^2 - s * p + m = 0 with the formula p = s/2 +/- sqrt((s/2)^2 - m)</span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        s - sum of primes (p + q)</span></span><br><span class="line"><span class="string">        m - product of primes (p * q)</span></span><br><span class="line"><span class="string">    Return: (p, q)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    half_s = s &gt;&gt; <span class="number">1</span></span><br><span class="line">    tmp = gmpy2.isqrt(half_s ** <span class="number">2</span> - m)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(half_s + tmp), <span class="built_in">int</span>(half_s - tmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wiener_attack</span>(<span class="params">n: <span class="built_in">int</span>, e: <span class="built_in">int</span></span>) -&gt; (<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Wiener&#x27;s Attack on RSA public key cryptosystem</span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        N - RSA modulus N = p*q</span></span><br><span class="line"><span class="string">        e - RSA public exponent</span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        A tuple of (p, q, d)</span></span><br><span class="line"><span class="string">        p, q - the two prime factors of RSA modulus N</span></span><br><span class="line"><span class="string">        d - RSA private exponent</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cfe = cf_expansion(e, n) <span class="comment"># Convert e/n into a continued fraction</span></span><br><span class="line">    cvg = cf_convergent(cfe) <span class="comment"># Get all of its convergents</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, d <span class="keyword">in</span> cvg:</span><br><span class="line">        <span class="comment"># Check if k and d meet the requirements</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">or</span> d % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> (e * d) % k != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># assume ed ≡ 1 (mod ϕ(n))</span></span><br><span class="line">        phi = (e * d - <span class="number">1</span>) // k </span><br><span class="line">        p, q = solve_rsa_primes(n - phi + <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> n == p * q:</span><br><span class="line">            <span class="keyword">return</span> p, q, d</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uint_to_bytes</span>(<span class="params">x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; This works only for unsigned (non-negative) integers.</span></span><br><span class="line"><span class="string">    It does not work for 0.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> x.to_bytes((x.bit_length() + <span class="number">7</span>) // <span class="number">8</span>, <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line">N = <span class="built_in">int</span>(</span><br><span class="line">    <span class="string">&#x27;6727075990400738687345725133831068548505159909089226&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;9093081511054056173840933739311418333016536024767844&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;14065504536979164089581789354173719785815972324079&#x27;</span>)</span><br><span class="line"></span><br><span class="line">e = <span class="built_in">int</span>(</span><br><span class="line">    <span class="string">&#x27;4805054278857670490961232238450763248932257077920876&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;3637915365038611552743522891345050097418639182479215&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;15546177391127175463544741368225721957798416107743&#x27;</span>)</span><br><span class="line"></span><br><span class="line">c = <span class="built_in">int</span>(</span><br><span class="line">    <span class="string">&#x27;5928120944877154092488159606792758283490469364444892&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;1679423458017133739626176287570534122326362199676752&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;56510422984948872954949616521392542703915478027634&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p, q, d = wiener_attack(N, e)</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> d <span class="keyword">is</span> <span class="literal">None</span>, <span class="string">&quot;Wiener&#x27;s Attack failed!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p =&quot;</span>, p)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;q =&quot;</span>, q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;d =&quot;</span>, d)</span><br><span class="line"><span class="built_in">print</span>(uint_to_bytes(<span class="built_in">pow</span>(c, d, N)))</span><br><span class="line"></span><br><span class="line">N = <span class="built_in">int</span>(</span><br><span class="line">    <span class="string">&#x27;22836858353287668091920368816286415778103964252589&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;28295130420474999022996621982166664596581454018899&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;48429922376560732622754871538043874356270300826321&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;16650572564937978011181394388679265524940467869924&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;85473650038355720409426235584833584188449224331698&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;63569900296911605460645581176522325967221393273906&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;69673188457131381644120787783215342848744792830245&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;01805598140668893320307200136190794138325132168722&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;14217943474001731747822701596634040292342194986951&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;94551646668806852454006312372413658692027515557841&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;41440661232146905186431357112566536770669381756925&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;38179415478954522854711968599279014482060579354284&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;55238863726089083&#x27;</span>)</span><br><span class="line"></span><br><span class="line">e = <span class="built_in">int</span>(</span><br><span class="line">    <span class="string">&#x27;17160819308904585327789016134897914235762203050367&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;34632679585567058963995675965428034906637374660531&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;64750599687461192166424505919293706011293378320096&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;43372382766547546926535697752805239918767190684796&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;26509298669049485976118315666126871681847641670872&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;58895073919139366379901867664076540531765577090231&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;67209821832859747419658344363466584895316847817524&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;24703257392651850823517297420382138943770358904660&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;59442300191228592937251734592732623207324742303631&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;32436274414264865868028527840102483762414082363751&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;87208612632105886502393648156776330236987329249988&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;11429508256124902530957499338336903951924035916501&#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;53661610070010419&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d = wiener_attack(N, e)</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> d <span class="keyword">is</span> <span class="literal">None</span>, <span class="string">&quot;Wiener&#x27;s attack failed!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;d =&quot;</span>, d)</span><br><span class="line"></span><br><span class="line">old_b = <span class="built_in">int</span>(gmpy2.root(N, <span class="number">4</span>)/<span class="number">3</span>)</span><br><span class="line">new_b = <span class="built_in">int</span>(gmpy2.root(N, <span class="number">4</span>)/gmpy2.root(<span class="number">18</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;old_b =&quot;</span>, old_b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;new_b =&quot;</span>, new_b)</span><br><span class="line"><span class="keyword">assert</span> d &gt; old_b <span class="keyword">and</span> d &lt;= new_b</span><br></pre></td></tr></table></figure>
<p>The code above ends with two test cases. Referring to the program output below, the first test case gives a small RSA modulus <span class="math inline">\(N\)</span> and a relatively large <span class="math inline">\(e\)</span>, which is precisely the scenario where Wiener's attack comes into play. The program calls the attack function wiener_attack() that quickly returns <span class="math inline">\(d\)</span> as 7, then decrypts a ciphertext and recovers the original plaintext "Wiener's attack success!".</p>
<p>The second test case sets a 2048-bit <span class="math inline">\(N\)</span> and <span class="math inline">\(e\)</span>, and Wiener's attack also succeeds swiftly. The program also verifies that the cracked <span class="math inline">\(d\)</span> (511 bits) is greater than the old bound <code>old_b</code> (<span class="math inline">\(N^{\frac 1 4}\)</span>), but slightly less than the new bound <code>new_b</code> (<span class="math inline">\(\frac 1 {\sqrt[4]{18}} N^\frac 1 4\)</span>). This confirms the conclusion of the University of Wollongong researchers.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p = 105192975360365123391387526351896101933106732127903638948310435293844052701259</span><br><span class="line">q = 63949859459297920725542167940404754256294386312715512490347273751054137071981</span><br><span class="line">d = 7</span><br><span class="line">b<span class="string">&quot;Wiener&#x27;s attack success!&quot;</span></span><br><span class="line">d = 5968166949079360555220268992852191823920023811474288738674370592596189517443887780023653031793516493806462114248181371416016184480421640973439863346079123</span><br><span class="line">old_b = 4097678063688683751669784036917434915284399064709500941393388469932708726583832656910141469383433913840738001283204519671690533047637554279688711463501824</span><br><span class="line">new_b = 5968166949079360962136673400587903792234115710617172051628964885379180548131448950677569697264501402772121272285767654845001503996650347315559383468867584</span><br></pre></td></tr></table></figure>
<p>These two test cases prove the effectiveness and prerequisites of Wiener's attack. To prevent Wiener's attack, the RSA private exponent <span class="math inline">\(d\)</span> must be greater than the upper bound. Choosing <span class="math inline">\(d\)</span> no less than <span class="math inline">\(N^{\frac 1 2}\)</span> is a more prudent scheme. In practice, <a href="https://www.packetmania.net/en/2023/11/14/Fermats-Little-Theorem/#optimized-rsa-decryption">the optimized decryption using Fermat's theorem and Chinese remainder theorem</a> is often used, so that even larger <span class="math inline">\(d\)</span> can achieve fast decryption and digital signing.</p>
<blockquote>
<p>To be continued, stay tuned for the next article: RSA: Attack and Defense (III)</p>
</blockquote>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>John Pollard, a British mathematician, the recipient of 1999 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/RSA_Award_for_Excellence_in_Mathematics">RSA Award for Excellence in Mathematics</a> for major contributions to algebraic cryptanalysis of integer factorization and discrete logarithm.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Richard Peirce Brent, an Australian mathematician and computer scientist, an emeritus professor at the Australian National University.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>M. Wiener, “<a target="_blank" rel="noopener" href="https://scholar.google.com/scholar?cluster=14819867265705249637&amp;hl=en&amp;as_sdt=0,5">Cryptanalysis of short RSA secret exponents</a>,” <em>IEEE Trans. Inform. Theory</em>, vol. 36, pp. 553–558, May 1990<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Adrien-Marie Legendre (1752-1833), a French mathematician who made numerous contributions to mathematics.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>Refer to <a href="https://www.packetmania.net/en/2022/08/20/picoCTF-Sum-O-Primes/">Solve picoCTF's RSA Challenge Sum-O-Primes</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>Dan Boneh, an Israeli–American professor in applied cryptography and computer security at Stanford University, a member of the National Academy of Engineering.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>Zixi
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="https://www.packetmania.net/en/2023/11/17/RSA-attack-defense-2/" title="RSA: Attack and Defense (II)">https://www.packetmania.net/en/2023/11/17/RSA-attack-defense-2/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-ND</a> unless stating additionally.
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/en/tags/Cryptography/" rel="tag"><i class="fa fa-tag"></i> Cryptography</a>
              <a href="/en/tags/Network-Security/" rel="tag"><i class="fa fa-tag"></i> Network Security</a>
              <a href="/en/tags/Python-Programming/" rel="tag"><i class="fa fa-tag"></i> Python Programming</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/en/2023/11/14/Fermats-Little-Theorem/" rel="prev" title="The Inductive Proof and Applications of Fermat's Little Theorem">
                  <i class="fa fa-chevron-left"></i> The Inductive Proof and Applications of Fermat's Little Theorem
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/en/2024/01/19/Purdue-MA265-2022-Fall-Midterm1/" rel="next" title="Purdue MA 26500 Fall 2022 Midterm I Solutions">
                  Purdue MA 26500 Fall 2022 Midterm I Solutions <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-gitalk">Gitalk Comments</a></li>
            <li class="tab"><a href="#comment-utterances">Utterances Comments</a></li>
            <li class="tab"><a href="#comment-disqus">Disqus Comments</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments gitalk-container"></div>
            </div>
            <div class="tab-pane utterances" id="comment-utterances">
              <div class="comments utterances-container"></div>
            </div>
            <div class="tab-pane disqus" id="comment-disqus">
              
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
            </div>
        </div>
      </div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zixi</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>Symbols count total: </span>
    <span title="Symbols count total">401k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>Reading time total &asymp;</span>
    <span title="Reading time total">6:04</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5fc1fd29017282c7" async="async"></script>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/next-boot.js"></script><script src="/en/js/bookmark.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/en/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.7/pdfobject.min.js","integrity":"sha256-ph3Dk89VmuTVXG6x/RDzk53SU9LPdAh1tpv0UvnDZ2I="},"url":"/en/lib/pdf/web/viewer.html"}</script>
  <script src="/en/js/third-party/tags/pdf.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"forest","dark":"forest"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@8.13.4/dist/mermaid.min.js","integrity":"sha256-96rwDGMWIQYB0yKGp1sKi1yrjrLPj2oT39IpbCsIrsg="}}</script>
  <script src="/en/js/third-party/tags/mermaid.js"></script>

  <script src="/en/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/en/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"packetmania-github-io","count":false,"i18n":{"disqus":"disqus"}}</script>
<script src="/en/js/third-party/comments/disqus.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"packetmania","repo":"en","client_id":"a45f6ae3f97c1a467856","client_secret":"7d81b74f952b388f93dcb5a8c44cd12f657969fa","admin_user":"packetmania","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"en","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"502a4f66b07ed7c63cf770f216f6626e"}</script>
<script src="/en/js/third-party/comments/gitalk.js"></script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"packetmania/en","issue_term":"pathname","theme":"github-light"}</script>
<script src="/en/js/third-party/comments/utterances.js"></script>

</body>
</html>
